# Monitoring github without webhook

是一个使用 Kubernetes `CronJob` 配合一个脚本来轮询 Git 仓库并触发 Tekton `EventListener` 的示例 YAML 配置。

这个方案包含以下几个部分：

1.  **一个 ConfigMap 用于存放轮询脚本。**
2.  **一个 ConfigMap 用于存放 Git 仓库的最新提交 SHA，作为状态存储。**
3.  **一个 ServiceAccount** 供 CronJob 的 Pod 使用。
4.  **一个 Role 和 RoleBinding** 赋予 ServiceAccount 读取和更新状态 ConfigMap 的权限。
5.  **一个 CronJob** 定义，它会定时运行一个 Pod，该 Pod 执行轮询脚本。

请注意：

*   你需要一个包含 `git`, `curl`, `kubectl` (或 `oc` 如果在 OpenShift 上), 和 `jq` 命令的容器镜像。你可以基于 `ubuntu` 或 `alpine` 构建一个简单的镜像，或者找一个包含这些工具的现有镜像。示例中使用了一个占位符镜像名 `my-custom-git-poller-image:latest`。
*   你需要替换 YAML 中的占位符，如仓库 URL、分支名、Tekton EventListener 的 Service 名称和命名空间等。
*   状态存储使用了 ConfigMap，脚本会读取其中的 `last-commit-sha` 字段，并在成功触发流水线后更新它。这要求 CronJob 的 ServiceAccount 有权限修改这个 ConfigMap。
*   这个方案的轮询频率取决于 `CronJob` 的 `schedule` 设置。

---

```yaml
# 1. ConfigMap for the Polling Script
# This ConfigMap holds the bash script that performs the polling logic.
apiVersion: v1
kind: ConfigMap
metadata:
  name: git-poller-script
  namespace: my-quarkus-app-01-dev # Change if your Tekton EventListener is in a different namespace
data:
  poll-and-trigger.sh: |
    #!/bin/bash

    set -euo pipefail

    REPO_URL="$1"
    BRANCH="$2"
    EVENT_LISTENER_SERVICE="$3" # Tekton EventListener Service Name
    TEKTON_NAMESPACE="$4"       # Tekton EventListener Namespace
    STATE_CONFIGMAP="$5"        # ConfigMap storing the last commit SHA
    STATE_CM_KEY="$6"           # Key within the state ConfigMap (e.g., last-commit-sha)
    CONFIGURED_USER_EMAIL="$7"  # New argument for configured email

    # Construct the EventListener URL (assuming cluster internal service discovery)
    EVENT_LISTENER_URL="http://el-${EVENT_LISTENER_SERVICE}.${TEKTON_NAMESPACE}.svc.cluster.local:8080"

    echo "Starting Git polling for ${REPO_URL} branch ${BRANCH}..."

    # 1. Get the latest commit SHA from the remote repository
    # Use git ls-remote for efficiency - avoids cloning
    CURRENT_COMMIT_SHA=$(git ls-remote "${REPO_URL}" "refs/heads/${BRANCH}" | awk '{print $1}')

    if [ -z "$CURRENT_COMMIT_SHA" ]; then
      echo "Error: Could not get current commit SHA from ${REPO_URL} on branch ${BRANCH}. Exiting."
      exit 1
    fi

    echo "Current commit SHA: ${CURRENT_COMMIT_SHA}"

    # 2. Read the last triggered commit SHA from the State ConfigMap
    # We need to handle the case where the ConfigMap or key doesn't exist yet (first run)
    set +e # Allow kubectl get to fail if CM/key not found initially
    LAST_COMMIT_SHA=$(kubectl get configmap "${STATE_CONFIGMAP}" -n "${TEKTON_NAMESPACE}" -o jsonpath="{.data.${STATE_CM_KEY}}" --ignore-not-found)
    set -e # Re-enable strict mode

    if [ -z "$LAST_COMMIT_SHA" ]; then
        echo "No previous commit SHA found in ConfigMap '${STATE_CONFIGMAP}' key '${STATE_CM_KEY}'. Assuming first run or state reset."
        LAST_COMMIT_SHA="<initial_sha>" # Use a placeholder that won't match a real SHA
    else
        echo "Last triggered commit SHA from state: ${LAST_COMMIT_SHA}"
    fi

    # 3. Compare SHAs and trigger if different
    if [ "$CURRENT_COMMIT_SHA" != "$LAST_COMMIT_SHA" ]; then
        echo "New commit detected! ${LAST_COMMIT_SHA} -> ${CURRENT_COMMIT_SHA}"
        echo "Triggering Tekton EventListener at ${EVENT_LISTENER_URL}..."

        # Construct a simple payload (mimicking part of a GitHub push webhook)
        # This payload must match what your Tekton TriggerBinding expects.
        # Ensure jq is available in your container image to build the JSON.
        PAYLOAD=$(jq -n \
            --arg ref "refs/heads/${BRANCH}" \
            --arg after "${CURRENT_COMMIT_SHA}" \
            --arg repo_url "${REPO_URL}" \
            --arg user_email "${CONFIGURED_USER_EMAIL}" \
            '{ref: $ref, after: $after, commits: $after, object_kind: "push", user_email: $user_email, repository: {git_http_url: $repo_url}}')

        echo "Sending payload: ${PAYLOAD}"

        # Send the POST request to the EventListener Service
        # -s: Silent mode
        # -o /dev/null: Discard output
        # -w "%{http_code}": Print only the HTTP status code
        response_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
                             -H "Content-Type: application/json" \
                             -d "${PAYLOAD}" \
                             "${EVENT_LISTENER_URL}")

        if [ "$response_code" -ge 200 ] && [ "$response_code" -lt 300 ]; then
            echo "Tekton EventListener triggered successfully (HTTP ${response_code})."

            # 4. Update the last triggered commit SHA in the State ConfigMap
            echo "Updating ConfigMap '${STATE_CONFIGMAP}' key '${STATE_CM_KEY}' with new SHA ${CURRENT_COMMIT_SHA}..."
            # Use kubectl patch to update the specific key in the data field
            kubectl patch configmap "${STATE_CONFIGMAP}" -n "${TEKTON_NAMESPACE}" \
                    --patch '{"data":{"'"${STATE_CM_KEY}"'":"'"${CURRENT_COMMIT_SHA}"'"}}'
            if [ $? -eq 0 ]; then
                echo "State ConfigMap updated successfully."
            else
                echo "Warning: Failed to update state ConfigMap. Subsequent runs might re-trigger for this commit."
                # Decide if you want the job to fail here. For polling state updates, maybe not critical.
            fi

        else
            echo "Error triggering Tekton EventListener. Received HTTP status code: ${response_code}."
            # If triggering fails, we should probably exit with an error so the Job is marked failed.
            exit 1
        fi

    else
        echo "No new commits detected. Latest SHA (${CURRENT_COMMIT_SHA}) matches last triggered SHA."
    fi

    echo "Polling job finished."

---
# 2. ConfigMap for Storing State (Last Triggered SHA)
# This ConfigMap holds the SHA of the last commit that successfully triggered a pipeline.
# You need to create this ConfigMap manually before the first run.
# The 'last-commit-sha' key should ideally be empty initially or contain a dummy value.
apiVersion: v1
kind: ConfigMap
metadata:
  name: git-polling-state # The name used in the script args
  namespace: my-quarkus-app-01-dev # Must match the namespace where the CronJob and EventListener run
data:
  last-commit-sha: "" # This will be updated by the script

---
# 3. ServiceAccount for the CronJob
# The CronJob Pod will run as this ServiceAccount.
apiVersion: v1
kind: ServiceAccount
metadata:
  name: git-poller-sa
  namespace: my-quarkus-app-01-dev # Must be in the same namespace as the CronJob and State ConfigMap

---
# 4. RBAC Role and RoleBinding
# These grant the ServiceAccount permission to get and patch the State ConfigMap.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: git-poller-state-updater-role
  namespace: my-quarkus-app-01-dev # Must be in the same namespace as the State ConfigMap
rules:
- apiGroups: [""] # Core Kubernetes API group
  resources: ["configmaps"]
  verbs: ["get", "patch"] # Need get to read and patch to update
  resourceNames: ["git-polling-state"] # Restrict to only the state ConfigMap

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: git-poller-state-updater-binding
  namespace: my-quarkus-app-01-dev # Must be in the same namespace as the Role and ServiceAccount
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: git-poller-state-updater-role # Name of the Role defined above
subjects:
- kind: ServiceAccount
  name: git-poller-sa # Name of the ServiceAccount defined above
  namespace: my-quarkus-app-01-dev # Must match the ServiceAccount's namespace

---
# 5. The CronJob Definition
apiVersion: batch/v1
kind: CronJob
metadata:
  name: git-repo-poller
  namespace: my-quarkus-app-01-dev # Must be in the same namespace as the ServiceAccount, ConfigMaps, and EventListener
spec:
  schedule: "*/5 * * * *" # Cron expression: runs every 5 minutes
  concurrencyPolicy: Forbid # Prevent concurrent job runs if a previous one is still running
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: git-poller-sa # Use the dedicated ServiceAccount
          restartPolicy: OnFailure # Restart the container if it fails, but the Job will finish if the container exits
          containers:
          - name: poller
            # Replace with your custom image containing git, curl, kubectl, and jq
            image: quay.io/wangzheng422/qimgs:rocky9-test-2025.04.30.v01
            imagePullPolicy: IfNotPresent
            command: ["/bin/bash", "/opt/script/poll-and-trigger.sh"]
            args:
            - "https://github.com/wangzheng422/docker_env"       # Replace with your Git repository URL (e.g., https://github.com/your-org/your-repo.git)
            - "dev"        # Replace with the branch name to poll (e.g., main or master)
            - "my-quarkus-app-01-el" # Replace with the name of your Tekton EventListener Service
            - "my-quarkus-app-01-dev"        # Replace if your EventListener is in a different namespace
            - "git-polling-state"       # Name of the state ConfigMap
            - "last-commit-sha"         # Key in the state ConfigMap
            - "your-configured-email@example.com" # Add the email as a new argument
            volumeMounts:
            - name: script-volume
              mountPath: /opt/script
          volumes:
          - name: script-volume
            configMap:
              name: git-poller-script # Mount the script ConfigMap
              defaultMode: 0755 # Make the script executable
```

**部署步骤：**

1.  **替换占位符：** 在上面的 YAML 中，将 `YOUR_GIT_REPO_URL`、`your-branch-name`、`your-eventlistener-name` 以及命名空间 `tekton-pipelines` 替换为你实际的值。同时，确保 `my-custom-git-poller-image:latest` 是你拥有的、包含了 `git`, `curl`, `kubectl`, `jq` 的容器镜像。
2.  **创建状态 ConfigMap：** 在部署 CronJob 之前，需要先创建用于存储状态的 ConfigMap：
    ```bash
    kubectl apply -f your-state-configmap.yaml # 将上面 YAML 中状态 ConfigMap 部分保存到文件
    ```
    或者直接使用上面的 YAML，只应用状态 ConfigMap 部分。
3.  **应用 RBAC：** 应用 ServiceAccount, Role 和 RoleBinding：
    ```bash
    kubectl apply -f your-rbac.yaml # 将上面 YAML 中 ServiceAccount, Role, RoleBinding 部分保存到文件
    ```
    或者直接使用上面的 YAML，只应用 RBAC 部分。
4.  **应用脚本 ConfigMap：** 应用存放脚本的 ConfigMap：
    ```bash
    kubectl apply -f your-script-configmap.yaml # 将上面 YAML 中脚本 ConfigMap 部分保存到文件
    ```
    或者直接使用上面的 YAML，只应用脚本 ConfigMap 部分。
5.  **应用 CronJob：** 最后，应用 CronJob 定义：
    ```bash
    kubectl apply -f your-cronjob.yaml # 将上面 YAML 中 CronJob 部分保存到文件
    ```
    或者直接使用上面的 YAML，只应用 CronJob 部分。

**注意事项：**

*   **镜像需求：** 构建或找到一个合适的容器镜像至关重要。确保镜像中包含所有必需的工具 (`git`, `curl`, `kubectl` 或 `oc`, `jq`) 并可在你的环境中运行。
*   **RBAC：** 务必确保为 `git-poller-sa` ServiceAccount 正确配置了权限，使其能够 `get` 和 `patch` `git-polling-state` ConfigMap。
*   **EventListener URL：** `http://${EVENT_LISTENER_SERVICE}.${TEKTON_NAMESPACE}.svc.cluster.local` 是 Kubernetes 集群内部的服务地址格式。如果你的 EventListener Service 类型是 `NodePort` 或 `LoadBalancer` 并在外部暴露，你可能需要调整脚本中的 URL 或通过 Ingress/Route 访问。
*   **状态持久性：** 这个方案的状态是存储在 ConfigMap 中的。如果 ConfigMap 被意外删除或修改，状态将会丢失，可能导致对旧提交的重复触发。更高级的方案可能使用数据库或专用的状态管理服务。
*   **错误处理：** 脚本包含基本的错误检查（如获取 SHA 失败、触发 EventListener 失败），但可以根据需要增加更复杂的重试逻辑和错误通知。
*   **Git 认证：** 如果你的 Git 仓库是私有的，你需要配置容器来处理认证（例如，通过挂载包含 Git 凭据的 Secret，并配置 Git 使用这些凭据）。这会使配置更复杂。`git ls-remote` 也可以通过 URL 嵌入凭据（不推荐）或使用 SSH 代理（更复杂）。
*   **API 速率限制：** 轮询频率过高可能会触犯 Git 托管服务（如 GitHub）的 API 速率限制。请根据你的 Git 服务提供商的文档和你的需求合理设置 `schedule`。

这个 YAML 提供了一个基本框架，你可以根据你的具体环境和需求进行调整。