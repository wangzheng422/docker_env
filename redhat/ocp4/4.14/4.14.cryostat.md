# JVM monitoring: cryostat on openshift 4.14

We want to monitor java app, to find out misbehaving, performance issue, etc. We can use `cryostat` to do this.

In this lab, we will use a buggy java app to demonstrate how to use `cryostat` to monitor it. This buggy java app will provide a web service, during each http request, it will create 1000 new thread to call backend service, which will cause the app to hang under traffic load.

offical docs:
- https://access.redhat.com/documentation/en-us/red_hat_build_of_cryostat/2

# install cert-manager

Install the cert-manager just from the operator hub.

![](imgs/2024-05-09-00-48-50.png)

# install cryostat

Selec the cryostat opeartor from operator hub

<!-- ![](imgs/2024-05-06-18-46-07.png) -->

![](imgs/2024-05-09-00-49-29.png)

Then, create a cryostat instance at app project/namespace

![](imgs/2024-05-07-15-52-03.png)

Keep cert-manager integration for our test.

<!-- ![](imgs/2024-05-07-15-53-53.png) -->

![](imgs/2024-05-08-23-42-44.png)

Craete a report instance, so we can see a general report of the app.

![](imgs/2024-05-07-15-54-26.png)

Give enough memory to the cryostat, otherwize the cryostat console will crash.

![](imgs/2024-05-07-15-57-07.png)

Enable storage

<!-- ![](imgs/2024-05-08-23-42-01.png) -->

![](imgs/2024-05-08-23-46-15.png)

Attach the ssl cert to the cryostat deployment, this is a requirement, because in redhat build of cryostat, the connect to app/jmx/agent, must be ssl enabled, otherwise the console will deny show result.

![](imgs/2024-05-07-15-57-49.png)

# try with the buggy java app in JMX way

There are several way to get monitoring data from app, one is JMX, another is agent, we will use JMX in this section, because it will only use jvm capabilities, and no need to change the app code.

```bash

# we need keytool from jdk
dnf install -y java-21-openjdk-devel

cd ${BASE_DIR}/data/install/

# Generate a Keystore
keytool -genkeypair -alias wzhlab -keyalg RSA -keystore keystore.jks -keysize 2048 -storepass redhat2024 -dname "CN=wzhlab-demo, OU=wzhlab-demo, O=wzhlab-demo, L=Beijing, ST=Beijing, C=CN" -validity $((365*100))
# Generating 2,048 bit RSA key pair and self-signed certificate (SHA384withRSA) with a validity of 36,500 days
#    for: CN=wzhlab-demo, OU=wzhlab-demo, O=wzhlab-demo, L=Beijing, ST=Beijing, C=CN

# Generate a Certificate Signing Request (CSR)
# keytool -certreq -alias wzhlab -file wzhlab.csr -keystore keystore.jks -storepass redhat2024

# Self-sign the CSR (if you don't have a Certificate Authority)
# keytool -gencert -alias wzhlab -infile wzhlab.csr -outfile wzhlab.crt -keystore keystore.jks -storepass redhat2024 -rfc

# create the certificate
keytool -exportcert -alias wzhlab -keystore keystore.jks -rfc -file wzhlab.crt -storepass redhat2024

oc create secret generic myapp-cert -n llm-demo \
  --from-file=tls.crt=${BASE_DIR}/data/install/wzhlab.crt \
  --from-file=keystore.jks=${BASE_DIR}/data/install/keystore.jks \
  --from-literal=storepass="redhat2024"

# oc delete secret myapp-cert -n llm-demo

# we prepare the jmx user/password
cat << EOF > ${BASE_DIR}/data/install/cryostat-user.yaml
monitor readonly
EOF

cat << EOF > ${BASE_DIR}/data/install/cryostat-pwd.yaml
monitor redhat
EOF

oc create configmap jmx-config -n llm-demo \
    --from-file=jmxremote.access=${BASE_DIR}/data/install/cryostat-user.yaml

oc create secret generic jmx-secret -n llm-demo \
    --from-file=jmxremote.password=${BASE_DIR}/data/install/cryostat-pwd.yaml

# go back to helper
# create a dummy pod
# we will disable JMX auth now for simplified, 
# will focus on agent way later.
cat << EOF > ${BASE_DIR}/data/install/demo1.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: wzh-demo-service
spec:
  ports:
    - name: service-port
      port: 80
      protocol: TCP
      targetPort: 8080
    - name: "jfr-jmx"
      port: 9091
      targetPort: 9091
    - name: "cryostat-agent"
      port: 9977
      targetPort: 9977
  selector:
    app: wzh-demo-pod

---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: wzh-demo
  annotations:
    haproxy.router.openshift.io/timeout: 2m
spec:
  to:
    kind: Service
    name: wzh-demo-service
  port:
    targetPort: service-port

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wzh-demo-deployment
  labels:
    app: wzh-demo-pod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wzh-demo-pod
  template:
    metadata:
      labels:
        app: wzh-demo-pod
    spec:
      # nodeSelector:
      #   kubernetes.io/hostname: 'worker-01-demo'
      containers:
        - name: demo1
          image: quay.io/wangzheng422/qimgs:simple-java-http-server-threads-2024.05.06.v01
          env:
            - name: WZH_URL
              value: "http://172.21.6.8:13000/singbox.config.json"
            - name: keyStorePassword
              valueFrom:
                secretKeyRef:
                  name: myapp-cert
                  key: storepass
            - name: JAVA_OPTS
              value: "-Dcom.sun.management.jmxremote.port=9091 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=true -Dcom.sun.management.jmxremote.registry.ssl=true -Djavax.net.ssl.keyStore=/jmx-keystore/keystore.jks -Djavax.net.ssl.keyStorePassword=\$(keyStorePassword) "
            # - name: JAVA_OPTS
            #   value: "-Dcom.sun.management.jmxremote.port=9091 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.password.file=/jmx-secret/jmxremote.password -Dcom.sun.management.jmxremote.access.file=/jmx-config/jmxremote.access"
            # command: [ "/bin/bash", "-c", "--" ]
            # args: [ "tail -f /dev/null" ]
            # imagePullPolicy: Always              
          volumeMounts:
            - name: jmx-config-volume
              mountPath: /jmx-config/
            - name: jmx-secret-volume
              mountPath: /jmx-secret/
            - name: keystore-volume
              mountPath: /jmx-keystore/
      volumes:
        - name: keystore-volume
          secret:
            secretName: myapp-cert
        - name: jmx-secret-volume
          secret:
            secretName: jmx-secret
        - name: jmx-config-volume
          configMap:
            name: jmx-config
EOF

oc apply -n llm-demo -f ${BASE_DIR}/data/install/demo1.yaml

# oc delete -n llm-demo -f ${BASE_DIR}/data/install/demo1.yaml

```

## see cryostat result

We do not have password setting, so we can see the app from the cryostat directly.

![](imgs/2024-05-07-12-36-55.png)

We can see apps in the project.

![](imgs/2024-05-07-12-37-12.png)

We can create report directly.

![](imgs/2024-05-07-12-37-56.png)

Set duration and template. Different template will have different KPI.

![](imgs/2024-05-07-12-38-43.png)

After the recording created, we can see the result in grafana, or download the jfr file to analyze offline.

![](imgs/2024-05-07-12-39-24.png)

get the username/password for graphana

```bash

oc get secret cryostat-sample-grafana-basic -n llm-demo -o jsonpath='{.data.GF_SECURITY_ADMIN_USER}' | base64 -d && echo
# admin

oc get secret cryostat-sample-grafana-basic -n llm-demo -o jsonpath='{.data.GF_SECURITY_ADMIN_PASSWORD}' | base64 -d && echo
# cQLRhe-X5jHVF6p0QuuA

```

Now, we can open the grafana console, and login.

![](imgs/2024-05-07-12-42-54.png)

We can switch to another dashboard to see the result.

![](imgs/2024-05-07-12-43-48.png)

you can also define automation rule to create reporting for pods belongs to deployment.

![](imgs/2024-05-07-12-53-53.png)

We can see the report is created automatically. Now lets see the analysis.

![](imgs/2024-05-07-12-52-41.png)

To limit the storage usage, you can limit the recording time, and number of archive, when you create automation rule.

![](imgs/2024-05-07-15-40-16.png)

Then you can get 2 archive, the file size is limited.

![](imgs/2024-05-07-15-40-52.png)

## testing with app

```bash
# test on helper
siege -q -c 1 -d 10 http://wzh-demo-llm-demo.apps.demo-gpu.wzhlab.top/sendRequest

```

and look at cryostat report, you can see it find out context switching, java blocking problems

![](imgs/2024-05-07-15-00-15.png)

and from grafana, we can see threads are increasing, so our buggy app is creating and closing threads all the times.

![](imgs/2024-05-07-15-01-29.png)

## analyze with jfr 

download jre/jdk at:
- https://adoptium.net/download/

download jmc at:
- https://adoptium.net/jmc/

download the jfr file:

![](imgs/2024-05-07-15-06-27.png)

open jmc, and open jfr file, you can see the overall result, just the same with cryostat analyse reporting.

<!-- ![](imgs/2024-05-06-19-39-41.png) -->

![](imgs/2024-05-07-15-17-41.png)

And you can go deeper to see the java app's overall result.

![](imgs/2024-05-07-15-17-07.png)

From socket view, you can see the connection report.

![](imgs/2024-05-07-15-19-21.png)

From the thread report, you can see app's thread behaviour is buggy. The thread view is slow, so you should give small jfr file if you want to open thread view.

![](imgs/2024-05-07-15-38-40.png)

## the priciple

by go to pod terminal, we can see, it just dump jfr file to /tmp, and then the cryostat will pick it up.

```bash

# get the first pod name from deployment
POD_NAME=$(oc get pod -n llm-demo -l app=wzh-demo-pod -o jsonpath='{.items[0].metadata.name}')

# login to pod, and list /tmp/ with folder like 2024_05_08_12_39_54_7
oc exec -n llm-demo $POD_NAME -it -- /bin/bash -c "ls -l /tmp/"
# total 0
# drwxr-xr-x. 2 1000720000 root 80 May  8 13:10 2024_05_08_12_39_54_7
# drwxr-xr-x. 2 1000720000 root 23 May  8 12:39 hsperfdata_1000720000
# drwxr-xr-x. 1 root       root 24 May  2 01:12 hsperfdata_root
# drwx------. 3 1000720000 root 26 May  8 12:39 tomcat.8080.3417839246973169794
# drwx------. 2 1000720000 root 10 May  8 12:39 tomcat-docbase.8080.14004372978732183802

oc exec -n llm-demo $POD_NAME -it -- /bin/bash -c "ls -l /tmp/2024_05_08_12_39_54_7"
# total 2760
# -rw-r--r--. 1 1000720000 root 1841833 May  8 13:10 2024_05_08_12_47_24.jfr
# -rw-r--r--. 1 1000720000 root  724150 May  8 13:18 2024_05_08_13_10_09.jfr

```

# try with the buggy java app in agent way

Download cryostat agent from upstream, find the correct versino based on the cryostat version. For this lab, it is cryostat 2.4.0, so we download the agent 0.3.0.

- https://github.com/cryostatio/cryostat-agent

We will follow opentelementry way, to build a new image with agent, and then deploy it with copy to java app container.

## agent.jar image

```bash

# on vultr
dnf install -y java-1.8.0-openjdk-devel java-21-openjdk-devel

dnf install -y /usr/bin/podman-compose /usr/bin/mvn


mkdir -p /data
cd /data

# download the jar from github
# https://github.com/cryostatio/cryostat-agent/packages/1601815?version=0.3.0

# and copy to server

cat << EOF > agent.dockerfile
FROM docker.io/rockylinux:9-minimal AS build

ADD cryostat-agent-0.3.0-shaded.jar /cryostat-agent-0.3.0-shaded.jar

EOF

podman build -t quay.io/wangzheng422/qimgs:cryostat-agent-v0.3.0 -f agent.dockerfile .

podman push quay.io/wangzheng422/qimgs:cryostat-agent-v0.3.0

```

## start buggy java app

Then, we will copy the agent to java app container, and start the agent.

```bash


```

# end